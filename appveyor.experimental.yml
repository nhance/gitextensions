version: 66.66.66.{build}

# Do not build on tags (GitHub, Bitbucket, GitLab, Gitea)
skip_tags: true

# set clone depth
clone_depth: 1                     # clone entire repository history if not defined

branches:
  only:
  - /experimental\/*/

matrix:
  fast_finish: false

# https://www.appveyor.com/docs/build-environment/#build-worker-images
image: Visual Studio 2022

environment:
  # Disable the .NET logo in the console output.
  DOTNET_NOLOGO: true
  # Disable the .NET first time experience to skip caching NuGet packages and speed up the build.
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  # Use latest version of current used .NET version.  6.0 could use the latest of 6.0.  See .\Scripts\Update-DotnetVersion.ps1
  GE_USE_LATEST_DOTNET: true

  # The following entries define the default values of the environment variables.
  # They can be overridden in AppVeyor | Settings | Environment.
  GE_TEST_SLEEP_SECONDS_ON_HANG: 0
  GE_TEST_LAUNCH_DEBUGGER_ON_HANG: 0
  # How many times to execute tests
  TEST_RUN_COUNT: 1
  # Execute unit tests
  RUN_UNIT_TESTS: 1
  # Execute integration tests
  RUN_INTEGRATION_TESTS: 1
  # Fail the build if any of the tests fail
  FAIL_BUILD_IF_TESTS_FAIL: 1

init:
  - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))

cache:
  # preserve "GitExtensions.PluginManager" directory, will be reset if appveyor.yml is modified
  - .\artifacts\publish\GitExtensions.PluginManager -> appveyor.yml

# Build settings, not to be confused with "before_build" and "after_build".
# "project" is relative to the original build directory and not influenced by directory changes in "before_build".
build:
  # enable MSBuild parallel builds
  parallel: true
  # MSBuild verbosity level
  verbosity: minimal

install:
- cmd: echo %APPVEYOR_REPO_COMMIT%
- cmd: echo %APPVEYOR_PULL_REQUEST_HEAD_COMMIT%
- ps: |
      if($env:GE_USE_LATEST_DOTNET -eq $true)
      {
        .\scripts\Update-DotnetVersion.ps1
      }
- ps: |
      Invoke-WebRequest "https://dot.net/v1/dotnet-install.ps1" -OutFile "./dotnet-install.ps1"
      ./dotnet-install.ps1 -JsonFile global.json -InstallDir 'C:\Program Files\dotnet'
- cmd: git submodule update --init --recursive
- cmd: echo /logger:"%ProgramFiles%\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll">> Directory.Build.rsp
- cmd: |-
    cd scripts
    C:\\Python35\\python set_version_to.py -v %APPVEYOR_BUILD_VERSION% -t %APPVEYOR_BUILD_VERSION%
    cd ..
    git --version


# to run your custom scripts instead of automatic MSBuild
build_script:
- ps: |
    $isBuildingPR = $false;
    # if building a temporary merge with master, soft reset to the PR commit so the build contains the PR's hash instead of the merge-commit's hash
    if ($env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT -and ($env:APPVEYOR_REPO_COMMIT -ne $env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT))
    {
        git reset --soft "$env:APPVEYOR_PULL_REQUEST_HEAD_COMMIT" --
        $isBuildingPR = $true;
    }
- ps: |
    # build VC++
    dotnet build .\scripts\native.proj -c Release --verbosity q --nologo /bl:.\artifacts\log\native.binlog
    if ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode) }
- ps: |
    # build .NET
    dotnet build -c Release --verbosity q --nologo /bl:.\artifacts\log\build.binlog /p:ContinuousIntegrationBuild=true
    if ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode) }
- ps: |
    # if we have reset above, we need to restore the merge commit, otherwise the loc verification step will fail
    # there is no need to have the same commit hash, but there must be no pending changes before the loc verification
    # refer to https://github.com/gitextensions/gitextensions/issues/7979
    if ($isBuildingPR) {
        git config user.email "gitextensions@github.com"
        git config user.name "Git Extensions"
        git -c core.autocrlf=false commit -a -m "restore merge commit" 2>&1
        # ignore warning about line-endings conversion
        $global:LASTEXITCODE = 0
    }
- ps: |
    # Verify that new strings (if any) have been processed and ready for localisation
    # it would be nice to run '.\cibuild.cmd -loc -logFileName localise.binlog /p:NoBuild=true' but it doesn't work without `-build` switch :\
    Push-Location .\GitExtensions
    dotnet msbuild /p:Configuration=Release /t:_UpdateEnglishTranslations /p:RunTranslationApp=true /p:ContinuousIntegrationBuild=true /v:m /bl:..\artifacts\log\localise.binlog
    Pop-Location
    if ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode) }


# to run your custom scripts instead of automatic tests
test_script:
- ps: |
    $failBuildIfTestsFail = $env:FAIL_BUILD_IF_TESTS_FAIL
    $runUnitTests         = $env:RUN_UNIT_TESTS
    $runIntegrationTests  = $env:RUN_INTEGRATION_TESTS
    $testRunCount         = $env:TEST_RUN_COUNT

    Write-Host "FAIL_BUILD_IF_TESTS_FAIL:        ${failBuildIfTestsFail}"
    Write-Host "RUN_UNIT_TESTS:                  ${runUnitTests}"
    Write-Host "RUN_INTEGRATION_TESTS:           ${runIntegrationTests}"
    Write-Host "TEST_RUN_COUNT:                  ${testRunCount}"
    Write-Host "GE_TEST_SLEEP_SECONDS_ON_HANG:   ${env:GE_TEST_SLEEP_SECONDS_ON_HANG}"
    Write-Host "GE_TEST_LAUNCH_DEBUGGER_ON_HANG: ${env:GE_TEST_LAUNCH_DEBUGGER_ON_HANG}"

    $testErrorsTotal = 0
    for ($testRun = 1; $testRun -le $testRunCount; $testRun++)
    {
        $failedBefore = if ($testRun -ne 1) { ", ${testErrorsTotal} test(s) failed before" }
        Write-Host ""
        Write-Host "[INFO]: Test Run ${testRun}/${testRunCount}${failedBefore}"

        if ($runUnitTests        -ne 0) { & dotnet test -c Release --no-restore --nologo --verbosity q --test-adapter-path:. --logger:Appveyor --logger:trx /bl:.\artifacts\log\tests.binlog }
        #if ($runIntegrationTests -ne 0) { & .\cibuild.cmd /p:NoBuild=true -integrationTest -logFileName IntegrationTest.binlog }

        Get-ChildItem -recurse artifacts\tests\TestResult.xml -ErrorAction SilentlyContinue `
        | ForEach-Object {
            $resultFilePath = "$_"
            Get-Content $resultFilePath `
            | Select-String -Pattern '<test-run id="[^"]*"\s+testcasecount="(\d+)"\s+result="([^"]*)"\s+total="(\d+)"\s+passed="(\d+)"\s+failed="(\d+)".*' `
            | foreach {
                $result = $_.Matches.Groups
                #$result[0].Value
                $total  = $result[1].Value
                $passed = $result[4].Value
                $failed = $result[5].Value
                $notPassed = $total - $passed
                $testErrors = $failed
                $testProjectName = $resultFilePath.Split('\\')[-3]
                $artifactName = "TestResult#${testRun}.${testErrors}err.${testProjectName}"
                Push-AppveyorArtifact $resultFilePath -FileName "${artifactName}.xml"
                if ($notPassed -ne 0) {
                    $logFile = Get-ChildItem -recurse artifacts\$testProjectName*.log
                    if ($testErrors -ne 0) { Push-AppveyorArtifact $logFile -FileName "${artifactName}.log" }
                }
                $testErrorsTotal += $testErrors
            }
        }
    }
    if ($testErrorsTotal -ne 0  -and  $failBuildIfTestsFail -ne 0) { $host.SetShouldExit($testErrorsTotal) }

# scripts to run after tests
after_test:
- ps: |
    Write-Host "Preparing build artifacts..."
    dotnet publish -c Release --no-build /bl:.\artifacts\log\publish.binlog /p:ContinuousIntegrationBuild=true
    if ($LastExitCode -ne 0) { $host.SetShouldExit($LastExitCode) }
- ps: |
    if ([bool]$env:APPVEYOR_PULL_REQUEST_TITLE -and [bool]$env:ARTIFACT_PUBLISH_PULL_REQUEST_MSI) {
        $msi = (Resolve-Path .\artifacts\Release\publish\GitExtensions-*.msi)[0].Path;
        Get-ChildItem $msi | % { Push-AppveyorArtifact $_.FullName -FileName $_.Name }
    }

artifacts:
  - path: artifacts\log\**\*.binlog
  - path: artifacts\Release\publish\*.zip

#on_finish:
#  - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))


# on build failure
on_failure:
- ps: |
    Get-ChildItem -recurse artifacts\log\*.binlog -ErrorAction SilentlyContinue `
    | ForEach-Object {
        Push-AppveyorArtifact "$_"
    }
- ps: |
    Get-ChildItem -recurse English*.xlf -ErrorAction SilentlyContinue `
    | ForEach-Object {
        Push-AppveyorArtifact "$_"
    }
- ps: |
    Get-ChildItem -recurse artifacts\Release\TestsResults\*.trx | `
        ForEach-Object {
            $file = $_.FullName.Replace('[', '``[').Replace(']', '``]')
            #Write-Output "Processing $file"

            [xml]$xml = Get-Content -Path $file
            $xml.TestRun.Results.UnitTestResult | Where-Object outcome -eq 'Failed' | ForEach-Object {
                $errorMessage = "$($_.Output.ErrorInfo.Message)`r`n$($_.Output.ErrorInfo.StackTrace)`r`n"
                Write-Host $errorMessage -ForegroundColor Red
            }
        }
